* osai-kube-storage-gateway todo list

** DONE Evaluate and Document Storage Needs

 Estimate size, type, and number of objects expected. Consider read/write access patterns.

 For v1, I just want to be able to read/write images from the various apps running in the cluster. I suspect I'll request 1-30 images at a time. I don't think I'll need to store videos. I might want to store text or json files when working with LLM's, but I may store that in a database rather than object storage. I won't worry about this yet.

** DONE Choose GCS Bucket Storage Class

 Select between Standard, Nearline, Coldline, or Archive based on data access needs.

 I already have a bucket set up. I'll use that one. I did read about these options though:

 #+begin_src md
# Edit default storage class

Changing this bucket's default storage class will affect objects uploaded after you save the new storage class. To change current objects' storage classes, use gsutil or the Cloud Storage API. Learn more

# Autoclass

Automatically transitions each object to Standard or Nearline class based on object-level activity, to optimize for cost and latency. Recommended if usage frequency may be unpredictable. Can be changed to a default class at any time. Pricing details

# Set a default class

Applies to all objects in your bucket unless you manually modify the class per object or set object lifecycle rules. Best when your usage is highly predictable. Can't be changed to Autoclass once the bucket is created.

## Standard

Best for short-term storage and frequently accessed data

## Nearline

Best for backups and data accessed less than once a month

## Coldline

Best for disaster recovery and data accessed less than once a quarter

## Archive

Best for long-term digital preservation of data accessed less than once a year
 #+end_src



** TODO Configure GCS Buckets

 Create buckets in GCS, setting appropriate locations and permissions.

** TODO Define IAM Roles

 Create specific IAM roles for access control to GCS with the principle of least privilege.

** TODO Create GCP Service Accounts

 Set up service accounts for your application, assigning necessary IAM roles.

** TODO Design PostgreSQL Schema

 Draft a schema for your database, focusing on tables for user data, access control, and object metadata.

** TODO Install PostgreSQL

 Choose between local Kubernetes deployment or cloud-based service. Install and initialize.

** TODO Develop User and Project Access Control Logic

 Code the logic for handling user and project-specific access, preparing for integration with Keycloak.

** TODO Write Dockerfile

 Craft a Dockerfile with Rust environment, including actix_web, diesel, and cloud-storage libraries.

** TODO Code Basic Web Server Structure

 Start with a basic Rust application structure using actix_web.

** TODO Set up Database Connection

 Integrate the PostgreSQL database with your Rust application using diesel.

** TODO Implement GCS Integration

 Develop functionality in your application for interacting with GCS (authentication, uploading, downloading).

** TODO Create Basic API Endpoints

 Start with primary endpoints for your object storage operations (e.g., POST for upload, GET for download).

** TODO Test Keycloak Integration

 Implement a test integration with Keycloak for authentication, using a mock endpoint.

** TODO Draft Kubernetes Deployment Manifest

 Write a basic deployment manifest for Kubernetes, including necessary environment variables.

** TODO Prepare Keycloak Client Setup

 Configure a client in Keycloak for your application with necessary scopes and roles.

** TODO Unit Test Core Functions

 Write and run unit tests for core functionalities like database interaction, GCS integration, and access control logic.

** TODO Build Initial Docker Image

 Build and test the Docker image locally to ensure all components are properly included.

** TODO Set Up Basic CI/CD Workflow

 Create a simple GitHub Actions workflow for build and test automation.

** TODO Perform Initial Database Migration

 Run the first database migration to set up your initial schema.

** TODO Deploy Initial Version to Kubernetes

 Deploy your application to Kubernetes and verify basic connectivity and functionality.

** TODO Integrate Application with osai-kube

 Ensure your new service communicates correctly with existing services in the osai-kube ecosystem.

** TODO Refine API Endpoints

 Expand and refine your API based on initial testing and requirements.

** TODO Optimize Dockerfile and Kubernetes Manifests

 Iterate on your Dockerfile and Kubernetes manifests for efficiency and best practices.
